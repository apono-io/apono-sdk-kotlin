/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.apono.sdk.api

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.apono.sdk.model.AccessFlowModelV3
import io.apono.sdk.model.CreateAccessFlowRequestV3
import io.apono.sdk.model.MessageResponse
import io.apono.sdk.model.PaginatedAccessFlowV3SearchResponse
import io.apono.sdk.model.UpdateAccessFlowModelV3

import com.fasterxml.jackson.annotation.JsonProperty

import io.apono.sdk.infrastructure.ApiClient
import io.apono.sdk.infrastructure.ApiResponse
import io.apono.sdk.infrastructure.ClientException
import io.apono.sdk.infrastructure.ClientError
import io.apono.sdk.infrastructure.ServerException
import io.apono.sdk.infrastructure.ServerError
import io.apono.sdk.infrastructure.MultiValueMap
import io.apono.sdk.infrastructure.PartConfig
import io.apono.sdk.infrastructure.RequestConfig
import io.apono.sdk.infrastructure.RequestMethod
import io.apono.sdk.infrastructure.ResponseType
import io.apono.sdk.infrastructure.Success
import io.apono.sdk.infrastructure.toMultiValue

class AccessFlowsApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.apono.io")
        }
    }

    /**
     * create access flow
     * 
     * @param createAccessFlowRequestV3 
     * @return AccessFlowModelV3
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createAccessFlow(createAccessFlowRequestV3: CreateAccessFlowRequestV3) : AccessFlowModelV3 {
        val localVarResponse = createAccessFlowWithHttpInfo(createAccessFlowRequestV3 = createAccessFlowRequestV3)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccessFlowModelV3
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * create access flow
     * 
     * @param createAccessFlowRequestV3 
     * @return ApiResponse<AccessFlowModelV3?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createAccessFlowWithHttpInfo(createAccessFlowRequestV3: CreateAccessFlowRequestV3) : ApiResponse<AccessFlowModelV3?> {
        val localVariableConfig = createAccessFlowRequestConfig(createAccessFlowRequestV3 = createAccessFlowRequestV3)

        return request<CreateAccessFlowRequestV3, AccessFlowModelV3>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createAccessFlow
     *
     * @param createAccessFlowRequestV3 
     * @return RequestConfig
     */
    fun createAccessFlowRequestConfig(createAccessFlowRequestV3: CreateAccessFlowRequestV3) : RequestConfig<CreateAccessFlowRequestV3> {
        val localVariableBody = createAccessFlowRequestV3
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v3/access-flows",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * delete access flow
     * 
     * @param id 
     * @return MessageResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteAccessFlow(id: kotlin.String) : MessageResponse {
        val localVarResponse = deleteAccessFlowWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MessageResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * delete access flow
     * 
     * @param id 
     * @return ApiResponse<MessageResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteAccessFlowWithHttpInfo(id: kotlin.String) : ApiResponse<MessageResponse?> {
        val localVariableConfig = deleteAccessFlowRequestConfig(id = id)

        return request<Unit, MessageResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteAccessFlow
     *
     * @param id 
     * @return RequestConfig
     */
    fun deleteAccessFlowRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v3/access-flows/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * get access flow
     * 
     * @param id 
     * @return AccessFlowModelV3
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccessFlow(id: kotlin.String) : AccessFlowModelV3 {
        val localVarResponse = getAccessFlowWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccessFlowModelV3
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * get access flow
     * 
     * @param id 
     * @return ApiResponse<AccessFlowModelV3?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccessFlowWithHttpInfo(id: kotlin.String) : ApiResponse<AccessFlowModelV3?> {
        val localVariableConfig = getAccessFlowRequestConfig(id = id)

        return request<Unit, AccessFlowModelV3>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccessFlow
     *
     * @param id 
     * @return RequestConfig
     */
    fun getAccessFlowRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v3/access-flows/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * list access flows
     * 
     * @param filters  (optional)
     * @param onlyActive  (optional, default to false)
     * @return PaginatedAccessFlowV3SearchResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listAccessFlows(filters: kotlin.String? = null, onlyActive: kotlin.Boolean? = false) : PaginatedAccessFlowV3SearchResponse {
        val localVarResponse = listAccessFlowsWithHttpInfo(filters = filters, onlyActive = onlyActive)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedAccessFlowV3SearchResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * list access flows
     * 
     * @param filters  (optional)
     * @param onlyActive  (optional, default to false)
     * @return ApiResponse<PaginatedAccessFlowV3SearchResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listAccessFlowsWithHttpInfo(filters: kotlin.String?, onlyActive: kotlin.Boolean?) : ApiResponse<PaginatedAccessFlowV3SearchResponse?> {
        val localVariableConfig = listAccessFlowsRequestConfig(filters = filters, onlyActive = onlyActive)

        return request<Unit, PaginatedAccessFlowV3SearchResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listAccessFlows
     *
     * @param filters  (optional)
     * @param onlyActive  (optional, default to false)
     * @return RequestConfig
     */
    fun listAccessFlowsRequestConfig(filters: kotlin.String?, onlyActive: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filters != null) {
                    put("filters", listOf(filters.toString()))
                }
                if (onlyActive != null) {
                    put("only_active", listOf(onlyActive.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v3/access-flows",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * update access flow
     * 
     * @param id 
     * @param updateAccessFlowModelV3 
     * @return AccessFlowModelV3
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateAccessFlow(id: kotlin.String, updateAccessFlowModelV3: UpdateAccessFlowModelV3) : AccessFlowModelV3 {
        val localVarResponse = updateAccessFlowWithHttpInfo(id = id, updateAccessFlowModelV3 = updateAccessFlowModelV3)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccessFlowModelV3
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * update access flow
     * 
     * @param id 
     * @param updateAccessFlowModelV3 
     * @return ApiResponse<AccessFlowModelV3?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateAccessFlowWithHttpInfo(id: kotlin.String, updateAccessFlowModelV3: UpdateAccessFlowModelV3) : ApiResponse<AccessFlowModelV3?> {
        val localVariableConfig = updateAccessFlowRequestConfig(id = id, updateAccessFlowModelV3 = updateAccessFlowModelV3)

        return request<UpdateAccessFlowModelV3, AccessFlowModelV3>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateAccessFlow
     *
     * @param id 
     * @param updateAccessFlowModelV3 
     * @return RequestConfig
     */
    fun updateAccessFlowRequestConfig(id: kotlin.String, updateAccessFlowModelV3: UpdateAccessFlowModelV3) : RequestConfig<UpdateAccessFlowModelV3> {
        val localVariableBody = updateAccessFlowModelV3
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v3/access-flows/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
